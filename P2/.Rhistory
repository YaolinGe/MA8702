sigma1=2 #Variance of GRF.
sigma=sigma1*sigma
mu  = rep(0,n*n) #Expected value 0.
Realisation = mvrnorm(n = 1, mu, sigma) #Sample one realisation.
Result=interp(x=kombi$Var1,y=kombi$Var2,z=Realisation) #Match element in Realisation to its position.
# Display the realisation
image.plot(Result, asp=1)
Realisation = mvrnorm(n = 1, mu, sigma) #Sample one realisation.
Result=interp(x=kombi$Var1,y=kombi$Var2,z=Realisation) #Match element in Realisation to its position.
# Display the realisation
image.plot(Result, asp=1)
library(fields);
plot(distance,CorrelationFunction,type="l")
sigma=matrix(data=0,nrow=(n*n),ncol=(n*n))
for (i in 1:(n*n))
{
for (j in 1:(n*n))
{
sigma[i,j] = exp(-dist[i,j]/theta1)
}
}
sigma1=2 #Variance of GRF.
sigma=sigma1*sigma
mu  = rep(0,n*n) #Expected value 0.
Realisation = mvrnorm(n = 1, mu, sigma) #Sample one realisation.
Result=interp(x=kombi$Var1,y=kombi$Var2,z=Realisation) #Match element in Realisation to its position.
# Display the realisation
image.plot(Result, asp=1)
library(fields);
library(geoR);
library(MASS)
#install.packages("akima")
library(akima)
n=20
kombi = expand.grid(seq(1,n, by=1), seq(1,n, by=1)) #Make n x n grid
dist = rdist(kombi, kombi)
#Correlation matrix, exponential covariance function
theta1=2
mynu=0.5
#Plot correlation function
distance=0:0.01:20
CorrelationFunction=Matern(distance,range = theta1,nu=mynu)
plot(distance,CorrelationFunction,type="l")
sigma=matrix(data=0,nrow=(n*n),ncol=(n*n))
for (i in 1:(n*n))
{
for (j in 1:(n*n))
{
sigma[i,j] = Matern(dist[i,j] , range = theta1,nu=mynu)
}
}
sigma1=20 #Variance of GRF.
sigma=sigma1*sigma
mu  = rep(0,n*n) #Expected value 0.
Realisation = mvrnorm(n = 1, mu, sigma) #Sample one realisation.
Result=interp(x=kombi$Var1,y=kombi$Var2,z=Realisation) #Match element in Realisation to its position.
# Display the realisation
image.plot(Result, asp=1)
---
title: "P2"
author: {"Yaolin Ge", "Florian Beiser"}
date: "3/16/2021"
output: pdf_document
---
---
title: "P2"
author: "Yaolin Ge", "Florian Beiser"
date: "3/16/2021"
output: pdf_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
plot(pressure)
source('~/.active-rstudio-document', echo=TRUE)
# }
RUN {
# NOT RUN {
require("grDevices") # for colours
x <- y <- seq(-4*pi, 4*pi, length.out = 27)
r <- sqrt(outer(x^2, y^2, "+"))
image(z = z <- cos(r^2)*exp(-r/6), col = gray.colors(33))
image(z, axes = FALSE, main = "Math can be beautiful ...",
xlab = expression(cos(r^2) * e^{-r/6}))
contour(z, add = TRUE, drawlabels = FALSE)
# Volcano data visualized as matrix. Need to transpose and flip
# matrix horizontally.
image(t(volcano)[ncol(volcano):1,])
# A prettier display of the volcano
x <- 10*(1:nrow(volcano))
y <- 10*(1:ncol(volcano))
image(x, y, volcano, col = hcl.colors(100, "terrain"), axes = FALSE)
contour(x, y, volcano, levels = seq(90, 200, by = 5),
add = TRUE, col = "brown")
axis(1, at = seq(100, 800, by = 100))
axis(2, at = seq(100, 600, by = 100))
box()
title(main = "Maunga Whau Volcano", font.main = 4)
# }
```{r covariance matrix, echo = F, fig.align='center'}
suppressPackageStartupMessages(library(knitr))
knitr::opts_chunk$set(echo = FALSE, message=FALSE,warning = FALSE, error = FALSE)
z = rnorm(100)
z
L
L.shape
L.dim
dim(L)
install.packages("crank")
x = 1:10
permute(x)
library(crank)
permute(x)
sites1v
source('~/.active-rstudio-document', echo=TRUE)
View(sites1v)
View(sites1v)
type(sites1v)
class(sites1v)
print(sample(c(1:10), size=10, replace=FALSE))
print(sample(c(1:10), size=11, replace=FALSE))
print(sample(c(1:10), size=9, replace=FALSE))
sites1v_per <- sample(sites1v, size = n, replace = FALSE)
sites1v_per
# Setup the grid
n1 = 25 # number of grid points along east direction
n2 = 25 # number of grid points along north direction
n = n1 * n2 # total number of grid points
dn1 = 1/n1
dn2 = 1/n2
sites1 = array((1:n1), c(n1, 1))
sites2 = array((1:n2), c(n2, 1))
ww1 = ones(c(n1, 1))
# Setup the grid
n1 = 25 # number of grid points along east direction
n2 = 25 # number of grid points along north direction
n = n1 * n2 # total number of grid points
dn1 = 1/n1
dn2 = 1/n2
sites1 = array((1:n1), c(n1, 1))
sites2 = array((1:n2), c(n2, 1))
ww1 = rep(1, n1)
ww2 = rep(1, n2)
sites1m = sites1 %*% t(ww1) # sites1m is the matrix version of sites1
sites2m = ww2 %*% t(sites2)
View(sites1m)
View(sites2m)
sites1v = matrix(sites1m, nrow = n, ncol = 1)
sites2v = matrix(sites2m, nrow = n, ncol = 1)
plot(sites1v, sites2v)
View(sites2v)
View(sites1v)
plot(sites1v, sites2v, '.')
plot(sites1v, sites2v, )
suppressPackageStartupMessages(library(knitr))
knitr::opts_chunk$set(echo = FALSE, message=FALSE,warning = FALSE, error = FALSE)
# Setup the grid
n1 = 25 # number of grid points along east direction
n2 = 25 # number of grid points along north direction
n = n1 * n2 # total number of grid points
dn1 = 1/n1
dn2 = 1/n2
sites1 = array((1:n1), c(n1, 1))
sites2 = array((1:n2), c(n2, 1))
ww1 = rep(1, n1)
ww2 = rep(1, n2)
sites1m = sites1 %*% t(ww1) # sites1m is the matrix version of sites1
sites2m = ww2 %*% t(sites2)
sites1v = matrix(sites1m, nrow = n, ncol = 1)
sites2v = matrix(sites2m, nrow = n, ncol = 1)
plot(sites1v, sites2v)
plot(sites1v, sites2v)
plot(sites1v, sites2v)
ddE = sites1v %*% matrix(rep(1, n), nrow = 1, ncol = n) - matrix(rep(1, n), nrow = n, ncol = 1) %*% t(sites1v)
dd2E = ddE * ddE
ddN = sites2v %*% matrix(rep(1, n), nrow = 1, ncol = n) - matrix(rep(1, n), nrow = n, ncol = 1) %*% t(sites2v)
dd2N = ddN * ddN
t = sqrt(dd2E + dd2N)
image(t, main = "distance matrix")
image(t, main = "distance matrix")
BETA_TRUE = matrix(c(beta1, beta2, beta3), nrow = 3, ncol = 1)
THETA_TRUE = matrix(c(sigma, phi, tau), nrow = 3, ncol = 1)
# Simulate the initial random field
alpha = 1.0 # beta as in regression model
sigma = 1.0  # scaling coef in matern kernel
phi = 10 # range coef in matern kernel
# eta = 10 # range coef in matern kernel
tau = .05 # iid noise
beta1 = -alpha
beta2 = alpha
beta3 = alpha
BETA_TRUE = matrix(c(beta1, beta2, beta3), nrow = 3, ncol = 1)
THETA_TRUE = matrix(c(sigma, phi, tau), nrow = 3, ncol = 1)
Matern_cov <- function(sigma, phi, t){
# param sigma: scaling coef
# param eta: range coef
# param t: distance matrix
# return: matern covariance
return(sigma ** 2 * (1 + phi * t) * np.exp(-phi * t))
}
# Setup the grid
n1 = 25 # number of grid points along east direction
n2 = 25 # number of grid points along north direction
n = n1 * n2 # total number of grid points
dn1 = 1/n1
dn2 = 1/n2
sites1 = array((1:n1), c(n1, 1))
sites2 = array((1:n2), c(n2, 1))
ww1 = rep(1, n1)
ww2 = rep(1, n2)
sites1m = sites1 %*% t(ww1) # sites1m is the matrix version of sites1
sites2m = ww2 %*% t(sites2)
sites1v = matrix(sites1m, nrow = n, ncol = 1)
sites2v = matrix(sites2m, nrow = n, ncol = 1)
plot(sites1v, sites2v)
# Compute the distance matrix
ddE = sites1v %*% matrix(rep(1, n), nrow = 1, ncol = n) - matrix(rep(1, n), nrow = n, ncol = 1) %*% t(sites1v)
dd2E = ddE * ddE
ddN = sites2v %*% matrix(rep(1, n), nrow = 1, ncol = n) - matrix(rep(1, n), nrow = n, ncol = 1) %*% t(sites2v)
dd2N = ddN * ddN
t = sqrt(dd2E + dd2N)
image(t, main = "distance matrix")
Sigma = Matern_cov(sigma, phi, t)  # matern covariance
# param sigma: scaling coef
# param eta: range coef
# param t: distance matrix
# return: matern covariance
return(sigma ** 2 * (1 + phi * t) * exp(-phi * t))
Matern_cov <- function(sigma, phi, t){
# param sigma: scaling coef
# param eta: range coef
# param t: distance matrix
# return: matern covariance
return(sigma ^ 2 * (1 + phi * t) * exp(-phi * t))
}
# Setup the grid
n1 = 25 # number of grid points along east direction
n2 = 25 # number of grid points along north direction
n = n1 * n2 # total number of grid points
dn1 = 1/n1
dn2 = 1/n2
sites1 = array((1:n1), c(n1, 1))
sites2 = array((1:n2), c(n2, 1))
ww1 = rep(1, n1)
ww2 = rep(1, n2)
sites1m = sites1 %*% t(ww1) # sites1m is the matrix version of sites1
sites2m = ww2 %*% t(sites2)
sites1v = matrix(sites1m, nrow = n, ncol = 1)
sites2v = matrix(sites2m, nrow = n, ncol = 1)
plot(sites1v, sites2v)
# Compute the distance matrix
ddE = sites1v %*% matrix(rep(1, n), nrow = 1, ncol = n) - matrix(rep(1, n), nrow = n, ncol = 1) %*% t(sites1v)
dd2E = ddE * ddE
dd2N = ddN * ddN
t = sqrt(dd2E + dd2N)
image(t, main = "distance matrix")
# C_theta = Sigma + tau ** 2 * np.identity(n)
image(Sigma, main = "matern cov")
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
diag(3)
theta
typeof(theta)
dim(theta)
beta
type(beta)
typeof(beta)
dim(beta)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
rbind(1, 2, 3)
source('~/.active-rstudio-document', echo=TRUE)
setwd("~/OneDrive - NTNU/NTNU/2021/MA8702/Project/P2")
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
suppressPackageStartupMessages(library(knitr))
knitr::opts_chunk$set(echo = FALSE, message=FALSE,warning = FALSE, error = FALSE)
#%%
C_matrix <- function(theta){
sigma = theta[1]
phi = theta[2]
tau = theta[3]
Sigma = Matern_cov(sigma, phi, t)
C = Fmatrix %*% Sigma %*% t(Fmatrix) + diag(M) * tau^2
return(C)
}
dC_dsigma <- function(theta){
# sigma = theta$sigma
# phi = theta$phi
# tau = theta$tau
sigma = theta[1]
phi = theta[2]
tau = theta[3]
Km = Matern_cov(1.0, phi, t) # t here is the distance matrix, H is the design matrix, similar to X
dC_dsgm = Fmatrix %*% Km %*% t(Fmatrix)
return(dC_dsgm)
}
dC_dphi <- function(theta){
sigma = theta[1]
phi = theta[2]
tau = theta[3]
Kn = sigma ^ 2 * (-phi * t) * exp(-phi * t)
return(Fmatrix %*% Kn %*% t(Fmatrix))
}
dC_dtau <- function(theta){
return(diag(M))
}
# Use fisher scoring to find MLE parameters
beta = rbind(-1.1, 1.1, 1.4)
theta = rbind(1.1, 8.5, .03)
MAX_ITER = 100
No_iter = 0
epsilon = 10
Beta = matrix(0, nrow = MAX_ITER, ncol = 3)
Likelihood = matrix(0, nrow = MAX_ITER, ncol = 1)
while (No_iter < MAX_ITER & epsilon > .0001){
C = C_matrix(theta)
beta = solve(t(G) %*% solve(C, G), t(G) %*% solve(C, y_sampled))
Beta[No_iter, ] = t(beta)
z = y_sampled - G %*% beta
lik = -M/2 * log(2 * pi) - 1/2 * log(det(C)) -  1/2 * t(z) %*% solve(C, z) # otherwise, it becomes inf
Likelihood[No_iter, ] = lik
# Find dC*/dtheta
dC_dSgm = dC_dsigma(theta)
dC_dPhi = dC_dphi(theta)
dC_dTau = dC_dtau(theta)
u_sigma = -1/2 * sum(diag(solve(C, dC_dSgm))) + 1/2 * t(z) %*% solve(C, dC_dSgm %*% solve(C, z))
u_eta = -1 / 2 * sum(diag(solve(C, dC_dPhi))) + 1 / 2 * t(z) %*% solve(C, dC_dPhi %*% solve(C, z))
u_tau = -1 / 2 * sum(diag(solve(C, dC_dTau))) + 1 / 2 * t(z) %*% solve(C, dC_dTau %*% solve(C, z))
u = rbind(u_sigma, u_eta, u_tau)
V11 = -1/2 * sum(diag(solve(C, (dC_dSgm %*% solve(C, dC_dSgm)))))
V12 = -1 / 2 * sum(diag(solve(C, (dC_dSgm %*% solve(C, dC_dPhi)))))
V13 = -1 / 2 * sum(diag(solve(C, (dC_dSgm %*% solve(C, dC_dTau)))))
V21 = -1 / 2 * sum(diag(solve(C, (dC_dPhi %*% solve(C, dC_dSgm)))))
V22 = -1 / 2 * sum(diag(solve(C, (dC_dPhi %*% solve(C, dC_dPhi)))))
V23 = -1 / 2 * sum(diag(solve(C, (dC_dPhi %*% solve(C, dC_dTau)))))
V31 = -1 / 2 * sum(diag(solve(C, (dC_dTau %*% solve(C, dC_dSgm)))))
V32 = -1 / 2 * sum(diag(solve(C, (dC_dTau %*% solve(C, dC_dPhi)))))
V33 = -1 / 2 * sum(diag(solve(C, (dC_dTau %*% solve(C, dC_dTau)))))
V = matrix(c(V11, V12, V13, V21, V22, V23, V31, V32, V33), nrow = 3, ncol = 3)
theta_new = theta - solve(V, u)  # here it is minus, but in the book, it says plus, needs to be rechecked
# epsilon = norm(theta_new - theta, type = "2") / norm(beta, type = "2")
epsilon = norm(abs(theta_new - theta), type = "2") / norm(theta, type = "2")
theta = theta_new
print(paste(epsilon , " , iter no is ", No_iter))
No_iter = No_iter + 1
}
#%%
C_matrix <- function(theta){
sigma = theta[1]
phi = theta[2]
tau = theta[3]
Sigma = Matern_cov(sigma, phi, t)
C = Fmatrix %*% Sigma %*% t(Fmatrix) + diag(M) * tau^2
return(C)
}
dC_dsigma <- function(theta){
# sigma = theta$sigma
# phi = theta$phi
# tau = theta$tau
sigma = theta[1]
phi = theta[2]
tau = theta[3]
Km = Matern_cov(1.0, phi, t) # t here is the distance matrix, H is the design matrix, similar to X
dC_dsgm = Fmatrix %*% Km %*% t(Fmatrix)
return(dC_dsgm)
}
dC_dphi <- function(theta){
sigma = theta[1]
phi = theta[2]
tau = theta[3]
Kn = sigma ^ 2 * (-phi * t) * exp(-phi * t)
return(Fmatrix %*% Kn %*% t(Fmatrix))
}
dC_dtau <- function(theta){
return(diag(M))
}
# Use fisher scoring to find MLE parameters
beta = rbind(-1.1, 1.1, 1.4)
theta = rbind(1.1, 8.5, .03)
MAX_ITER = 100
No_iter = 0
epsilon = 10
Beta = matrix(0, nrow = MAX_ITER, ncol = 3)
Likelihood = matrix(0, nrow = MAX_ITER, ncol = 1)
while (No_iter < MAX_ITER & epsilon > .0001){
C = C_matrix(theta)
beta = solve(t(G) %*% solve(C, G), t(G) %*% solve(C, y_sampled))
Beta[No_iter, ] = t(beta)
z = y_sampled - G %*% beta
lik = -M/2 * log(2 * pi) - 1/2 * log(det(C)) -  1/2 * t(z) %*% solve(C, z) # otherwise, it becomes inf
if (lik != Inf){
lik = lik
}
else{
lik = 0
}
Likelihood[No_iter, ] = lik
# Find dC*/dtheta
dC_dSgm = dC_dsigma(theta)
dC_dPhi = dC_dphi(theta)
dC_dTau = dC_dtau(theta)
u_sigma = -1/2 * sum(diag(solve(C, dC_dSgm))) + 1/2 * t(z) %*% solve(C, dC_dSgm %*% solve(C, z))
u_eta = -1 / 2 * sum(diag(solve(C, dC_dPhi))) + 1 / 2 * t(z) %*% solve(C, dC_dPhi %*% solve(C, z))
u_tau = -1 / 2 * sum(diag(solve(C, dC_dTau))) + 1 / 2 * t(z) %*% solve(C, dC_dTau %*% solve(C, z))
u = rbind(u_sigma, u_eta, u_tau)
V11 = -1/2 * sum(diag(solve(C, (dC_dSgm %*% solve(C, dC_dSgm)))))
V12 = -1 / 2 * sum(diag(solve(C, (dC_dSgm %*% solve(C, dC_dPhi)))))
V13 = -1 / 2 * sum(diag(solve(C, (dC_dSgm %*% solve(C, dC_dTau)))))
V21 = -1 / 2 * sum(diag(solve(C, (dC_dPhi %*% solve(C, dC_dSgm)))))
V22 = -1 / 2 * sum(diag(solve(C, (dC_dPhi %*% solve(C, dC_dPhi)))))
V23 = -1 / 2 * sum(diag(solve(C, (dC_dPhi %*% solve(C, dC_dTau)))))
V31 = -1 / 2 * sum(diag(solve(C, (dC_dTau %*% solve(C, dC_dSgm)))))
V32 = -1 / 2 * sum(diag(solve(C, (dC_dTau %*% solve(C, dC_dPhi)))))
V33 = -1 / 2 * sum(diag(solve(C, (dC_dTau %*% solve(C, dC_dTau)))))
V = matrix(c(V11, V12, V13, V21, V22, V23, V31, V32, V33), nrow = 3, ncol = 3)
theta_new = theta - solve(V, u)  # here it is minus, but in the book, it says plus, needs to be rechecked
# epsilon = norm(theta_new - theta, type = "2") / norm(beta, type = "2")
epsilon = norm(abs(theta_new - theta), type = "2") / norm(theta, type = "2")
theta = theta_new
print(paste(epsilon , " , iter no is ", No_iter))
No_iter = No_iter + 1
}
#%%
C_matrix <- function(theta){
sigma = theta[1]
phi = theta[2]
tau = theta[3]
Sigma = Matern_cov(sigma, phi, t)
C = Fmatrix %*% Sigma %*% t(Fmatrix) + diag(M) * tau^2
return(C)
}
dC_dsigma <- function(theta){
# sigma = theta$sigma
# phi = theta$phi
# tau = theta$tau
sigma = theta[1]
phi = theta[2]
tau = theta[3]
Km = Matern_cov(1.0, phi, t) # t here is the distance matrix, H is the design matrix, similar to X
dC_dsgm = Fmatrix %*% Km %*% t(Fmatrix)
return(dC_dsgm)
}
dC_dphi <- function(theta){
sigma = theta[1]
phi = theta[2]
tau = theta[3]
Kn = sigma ^ 2 * (-phi * t) * exp(-phi * t)
return(Fmatrix %*% Kn %*% t(Fmatrix))
}
dC_dtau <- function(theta){
return(diag(M))
}
# Use fisher scoring to find MLE parameters
beta = rbind(-1.1, 1.1, 1.4)
theta = rbind(1.1, 8.5, .03)
MAX_ITER = 100
No_iter = 0
epsilon = 10
Beta = matrix(0, nrow = MAX_ITER, ncol = 3)
Likelihood = matrix(0, nrow = MAX_ITER, ncol = 1)
while (No_iter < MAX_ITER & epsilon > .0001){
C = C_matrix(theta)
beta = solve(t(G) %*% solve(C, G), t(G) %*% solve(C, y_sampled))
Beta[No_iter, ] = t(beta)
z = y_sampled - G %*% beta
lik = -M/2 * log(2 * pi) - 1/2 * log(det(C)) -  1/2 * t(z) %*% solve(C, z) # otherwise, it becomes inf
if (lik){
lik = lik
}
else{
lik = 0
}
Likelihood[No_iter, ] = lik
# Find dC*/dtheta
dC_dSgm = dC_dsigma(theta)
dC_dPhi = dC_dphi(theta)
dC_dTau = dC_dtau(theta)
u_sigma = -1/2 * sum(diag(solve(C, dC_dSgm))) + 1/2 * t(z) %*% solve(C, dC_dSgm %*% solve(C, z))
u_eta = -1 / 2 * sum(diag(solve(C, dC_dPhi))) + 1 / 2 * t(z) %*% solve(C, dC_dPhi %*% solve(C, z))
u_tau = -1 / 2 * sum(diag(solve(C, dC_dTau))) + 1 / 2 * t(z) %*% solve(C, dC_dTau %*% solve(C, z))
u = rbind(u_sigma, u_eta, u_tau)
V11 = -1/2 * sum(diag(solve(C, (dC_dSgm %*% solve(C, dC_dSgm)))))
V12 = -1 / 2 * sum(diag(solve(C, (dC_dSgm %*% solve(C, dC_dPhi)))))
V13 = -1 / 2 * sum(diag(solve(C, (dC_dSgm %*% solve(C, dC_dTau)))))
V21 = -1 / 2 * sum(diag(solve(C, (dC_dPhi %*% solve(C, dC_dSgm)))))
V22 = -1 / 2 * sum(diag(solve(C, (dC_dPhi %*% solve(C, dC_dPhi)))))
V23 = -1 / 2 * sum(diag(solve(C, (dC_dPhi %*% solve(C, dC_dTau)))))
V31 = -1 / 2 * sum(diag(solve(C, (dC_dTau %*% solve(C, dC_dSgm)))))
V32 = -1 / 2 * sum(diag(solve(C, (dC_dTau %*% solve(C, dC_dPhi)))))
V33 = -1 / 2 * sum(diag(solve(C, (dC_dTau %*% solve(C, dC_dTau)))))
V = matrix(c(V11, V12, V13, V21, V22, V23, V31, V32, V33), nrow = 3, ncol = 3)
theta_new = theta - solve(V, u)  # here it is minus, but in the book, it says plus, needs to be rechecked
# epsilon = norm(theta_new - theta, type = "2") / norm(beta, type = "2")
epsilon = norm(abs(theta_new - theta), type = "2") / norm(theta, type = "2")
theta = theta_new
print(paste(epsilon , " , iter no is ", No_iter))
No_iter = No_iter + 1
}
Fmatrix = matrix(0, M, n)
ind = sample(n, size = M, replace = FALSE)
for (i in c(1:M)){
Fmatrix[i, ind[i]] = TRUE
}
G = Fmatrix %*% H
y_sampled = Fmatrix %*% mu_real + tau * rnorm(M, 1)
x_ind = sites1v[ind]
y_ind = sites2v[ind]
plot(x_ind, y_ind,
plot(x_ind, y_ind, cex = abs(y_sampled), main = "Random samples in the grid, circle size indicates the relative value")
)
